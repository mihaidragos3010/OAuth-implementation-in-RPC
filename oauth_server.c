/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "oauth.h"
#include "library/server/token.h"
#include "library/server/utils.h"

User *users;
int nrUsers;
Permission **permissions;
int nrPermissions;
char** resourcesFiles;
int nrResourcesFiles;
int defaultTTL;

// Function is used to get a client id and return an auth token if client is recognized
ResponseAuthToken* request_auth_token_1_svc(RequestAuthToken *argp, struct svc_req *rqstp)
{
	static ResponseAuthToken  result;

	char* idClient = argp[0].idClient;
	bool isAutoRefreshActivated = argp[0].isAutoRefreshActivated;
	
	if(isIdAllowed(idClient)){

		result.header = strdup("SUCCESS");
		result.auth_token = generate_access_token(idClient);
		saveAuthToken(idClient, result.auth_token, isAutoRefreshActivated);

		printf("BEGIN %s AUTHZ\n", idClient);
		printf("  RequestToken = %s\n", result.auth_token);
		fflush(stdout);

	}else{

		result.header = strdup("USER_NOT_FOUND");

		printf("BEGIN %s AUTHZ\n", idClient);
		fflush(stdout);

	}

	return &result;
}

// Function is used to get an auth token and append to them some permissions. 
// The token(auth token, perms) is encrypted using server secret key (key = 15)
// Signed token is send back to the user
// If perms selected for this client are "*,-" then client get "REQUEST_DENIED" response without a signed token.
ResponseSignedToken* request_signed_token_1_svc(char **argp, struct svc_req *rqstp)
{
	static ResponseSignedToken  result;
	
	char* auth_token = argp[0];

	Permission *clientPermissions = getNextPossiblePermission(permissions, nrPermissions);

	if(isAcceptedByUsed(clientPermissions)){

		result.header = strdup("SUCCESS");
		char *unsigned_token = appendAuthTokenAndClientPermissions(auth_token, clientPermissions);
		result.signed_token = encrypt(unsigned_token);

	}else{

		result.header = strdup("REQUEST_DENIED");

	}

	return &result;
}

// Function is used to get bearer token based on a signed token
ResponseBearerToken* request_bearer_token_1_svc(char **argp, struct svc_req *rqstp)
{
	static ResponseBearerToken  result;
	result.header = calloc(1, 20);
	result.refresh_token = calloc(1, TOKEN_LEN);
	result.ttl = defaultTTL;
	
	char* signed_token = argp[0];
	char* unsigned_token = decrypt(signed_token);

	char *auth_token;
	Permission *clientPermissions;
	int nr = getAuthTokenAndClientPermissions(unsigned_token, &auth_token, &clientPermissions);

	result.access_token = generate_access_token(auth_token);
	printf("  AccessToken = %s\n", result.access_token);

	if(isAutoRefreshTokenUser(auth_token)){
		result.refresh_token = generate_access_token(result.access_token);
		printf("  RefreshToken = %s\n", result.refresh_token);
	}
	fflush(stdout);
	saveBearerToken(auth_token, result.access_token, result.refresh_token, defaultTTL, clientPermissions);

	return &result;
}

// Function is used to get new bearer token based on refresh token 
ResponseBearerToken* request_new_bearer_token_1_svc(char **argp, struct svc_req *rqstp)
{
	static ResponseBearerToken  result;

	char *refresh_token = argp[0];
	if(strlen(refresh_token) > 0){
		result.header = strdup("SUCCESS");
		result.access_token = generate_access_token(refresh_token);
		result.refresh_token = generate_access_token(result.access_token);
		result.ttl = defaultTTL;
		saveBearerTokenUsingRefreshToken(refresh_token, result.access_token, result.refresh_token, result.ttl);
	}else {
		result.header = strdup("NOT_ACCEPTED_REFRESH_TOKEN");
	}

	return &result;
}

// Function is used to receive client commands and check that credentials and permissions are valid
ResponseDatabaseAction* execute_databasa_action_1_svc(ExecuteDatabaseAction *argp, struct svc_req *rqstp)
{
	static ResponseDatabaseAction  result;

	ExecuteDatabaseAction execute_databasa_action = argp[0];

	for(int i=0; i<nrUsers; i++){
        if(strcmp(users[i].access_token, execute_databasa_action.access_token) == 0){
            users[i].ttl--;
		}
	}
	
	if(!isResourcesFile(execute_databasa_action.file)){
		result.header = strdup("RESOURCE_NOT_FOUND");
		logNotResourceFileFound(execute_databasa_action.action, execute_databasa_action.file, execute_databasa_action.access_token);
		return &result;
	}

	if(!isAccessTokenRecognized(execute_databasa_action.access_token)){
		result.header = strdup("PERMISSION_DENIED");
		logAccessTokenNotRecognized(execute_databasa_action.action, execute_databasa_action.file, execute_databasa_action.access_token);
		return &result;
	}

	if(isAccessTokenExpired(execute_databasa_action.access_token)){
		printf("DENY (%s,%s,,0)\n", execute_databasa_action.action, execute_databasa_action.file);
		fflush(stdout);
		result.header = strdup("TOKEN_EXPIRED");
		return &result;
	}

	if(!isAccessTokenAllowedToExecutThisAction(execute_databasa_action.access_token, 
											execute_databasa_action.action, 
											execute_databasa_action.file)){
		result.header = strdup("OPERATION_NOT_PERMITTED");
		return &result;
	}

	result.header = strdup("PERMISSION_GRANTED");

	return &result;
}
